function calculateInventoryRequirements() {
  try {
    // Get all worksheets
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const wsInv = ss.getSheetByName("Inventory");
    const wsRecipes = ss.getSheetByName("Recipes");
    const wsPlan = ss.getSheetByName("Kitting_Plan");
    const wsReq = ss.getSheetByName("Requirements");
    const wsSlotting = ss.getSheetByName("Slotting File"); // New slotting sheet
    
    // Check if all sheets exist
    if (!wsInv || !wsRecipes || !wsPlan || !wsReq) {
      throw new Error("One or more required sheets not found. Please ensure you have: Inventory, Recipes, Kitting_Plan, and Requirements sheets.");
    }
    
    // Check if slotting sheet exists (optional - will work without it but show warning)
    if (!wsSlotting) {
      console.log("Warning: Slotting File sheet not found. Location IDs will not be included.");
    }
    
    // Clear existing requirements
    wsReq.clear();
    
    // Add headers (now including Location Id)
    wsReq.getRange("A1:G1").setValues([["Item Number", "Item Description", "Location Id", "Total Required", "Current Inventory", "Difference", "Cases Needed"]]);
    
    // Get data ranges
    const inventoryData = wsInv.getDataRange().getValues();
    const recipesData = wsRecipes.getDataRange().getValues();
    const planData = wsPlan.getDataRange().getValues();
    
    // Get slotting data if available
    let slottingData = [];
    if (wsSlotting) {
      slottingData = wsSlotting.getDataRange().getValues();
      console.log("Slotting data rows:", slottingData.length);
    }
    
    console.log("Inventory rows:", inventoryData.length);
    console.log("Recipes rows:", recipesData.length);
    console.log("Plan rows:", planData.length);
    
    // Debug: Show structures
    console.log("Recipes headers:", recipesData[0]);
    console.log("Kitting Plan headers:", planData[0]);
    if (slottingData.length > 0) console.log("Slotting headers:", slottingData[0]);
    if (recipesData.length > 1) console.log("Sample recipe row:", recipesData[1]);
    if (planData.length > 1) console.log("Sample plan row:", planData[1]);
    if (slottingData.length > 1) console.log("Sample slotting row:", slottingData[1]);
    
    // Create dictionaries for case sizes, current inventory, and location IDs
    const dictCaseSizes = {};
    const dictCurrentInventory = {};
    const dictLocationIds = {}; // New dictionary for location IDs
    
    // Load case sizes and current inventory from Inventory sheet
    // Assuming: A=Item#, B=Description, C=CaseSize, D=CurrentQty
    for (let i = 1; i < inventoryData.length; i++) {
      const itemNum = inventoryData[i][0]; // Column A - Item Number
      const caseSize = inventoryData[i][2]; // Column C - Case Size
      const currentQty = inventoryData[i][3]; // Column D - Current Inventory
      
      if (itemNum) {
        // Convert case size to number
        let caseSizeNum = 1; // Default to 1
        if (caseSize !== null && caseSize !== undefined && caseSize !== "") {
          if (typeof caseSize === 'number') {
            caseSizeNum = caseSize;
          } else if (typeof caseSize === 'string') {
            caseSizeNum = parseFloat(caseSize.toString().replace(/[^0-9.-]/g, ''));
          }
        }
        dictCaseSizes[itemNum] = isNaN(caseSizeNum) || caseSizeNum <= 0 ? 1 : caseSizeNum;
        
        // Store current inventory
        dictCurrentInventory[itemNum] = parseFloat(currentQty) || 0;
      }
    }
    
    // Load location IDs from Slotting File sheet
    // Assuming: A=Location Id, B=Item Description, C=Item Number
    if (slottingData.length > 0) {
      for (let i = 1; i < slottingData.length; i++) {
        const locationId = slottingData[i][0]; // Column A - Location Id
        const itemNum = slottingData[i][2]; // Column C - Item Number
        
        if (itemNum && locationId) {
          dictLocationIds[itemNum] = locationId;
        }
      }
      console.log(`Loaded ${Object.keys(dictLocationIds).length} location mappings from slotting file`);
    }
    
    // Create a dictionary to store total requirements per SKU
    const skuTotalRequirements = {};
    const skuDescriptions = {};
    
    // Process all recipe rows to calculate total requirements per SKU
    for (let i = 1; i < recipesData.length; i++) {
      const recipeNum = recipesData[i][1]; // Column B - Recipe Number/Code (handles both numbers and letters)
      const itemDesc = recipesData[i][3]; // Column D - Item Description  
      const qty2p = parseFloat(recipesData[i][4]) || 0; // Column E - 2p quantity
      const qty4p = parseFloat(recipesData[i][5]) || 0; // Column F - 4p quantity
      const itemNum = recipesData[i][6]; // Column G - Item Number (SKU)
      
      if (itemNum && recipeNum !== null && recipeNum !== undefined && recipeNum !== "") {
        // Initialize SKU in dictionaries if not exists
        if (!skuTotalRequirements[itemNum]) {
          skuTotalRequirements[itemNum] = 0;
          skuDescriptions[itemNum] = itemDesc || "Unknown Item";
        }
        
        // Find the production plan for this recipe
        let plan2p = 0;
        let plan4p = 0;
        let foundPlan = false;
        
        for (let k = 1; k < planData.length; k++) {
          // Handle both numeric and text recipe codes by comparing as strings
          const planRecipe = planData[k][0]; // Column A - Recipe code from kitting plan
          
          // Compare recipes as strings to handle both numbers and letters
          if (String(planRecipe) === String(recipeNum)) {
            plan2p = parseFloat(planData[k][1]) || 0; // Column B - 2p plan
            plan4p = parseFloat(planData[k][2]) || 0; // Column C - 4p plan
            foundPlan = true;
            break;
          }
        }
        
        // Skip this item if no kitting plan found, but continue processing
        if (!foundPlan) {
          console.log(`Warning: No kitting plan found for Recipe ${recipeNum}, SKU ${itemNum} - skipping`);
        } else {
          // Calculate requirements for this recipe/SKU combination
          const req2p = qty2p * plan2p;
          const req4p = qty4p * plan4p;
          const totalReqForThisRecipe = req2p + req4p;
          
          // Add to the SKU total
          skuTotalRequirements[itemNum] += totalReqForThisRecipe;
          
          console.log(`Recipe ${recipeNum}, SKU ${itemNum}: 2p(${qty2p}*${plan2p}=${req2p}) + 4p(${qty4p}*${plan4p}=${req4p}) = ${totalReqForThisRecipe}. Running total: ${skuTotalRequirements[itemNum]}`);
        }
      }
    }
    
    console.log(`\nFound ${Object.keys(skuTotalRequirements).length} unique SKUs`);
    
    // Create results array
    const results = [];
    
    for (const itemNum in skuTotalRequirements) {
      const itemDesc = skuDescriptions[itemNum];
      const locationId = dictLocationIds[itemNum] || "Not Found"; // Get location ID or default
      const totalRequired = skuTotalRequirements[itemNum];
      const currentInventory = dictCurrentInventory[itemNum] || 0;
      const difference = currentInventory - totalRequired;
      
      // Calculate cases needed
      let casesNeeded = 0;
      if (totalRequired > 0) {
        const caseSize = dictCaseSizes[itemNum] || 1;
        casesNeeded = Math.ceil(totalRequired / caseSize);
      }
      
      console.log(`Final - SKU ${itemNum}: Location ${locationId}, Total Required = ${totalRequired}, Cases Needed = ${casesNeeded}`);
      
      // Add to results (now includes location ID in column C)
      results.push([itemNum, itemDesc, locationId, totalRequired, currentInventory, difference, casesNeeded]);
    }
    
    // Sort results by Location Id first, then by Item Number for easier reading
    results.sort((a, b) => {
      // First sort by Location Id (column 2)
      if (a[2] < b[2]) return -1;
      if (a[2] > b[2]) return 1;
      
      // If Location Ids are the same, sort by Item Number (column 0)
      if (a[0] < b[0]) return -1;
      if (a[0] > b[0]) return 1;
      return 0;
    });
    
    // Write results to sheet
    if (results.length > 0) {
      wsReq.getRange(2, 1, results.length, 7).setValues(results); // Now 7 columns instead of 6
      
      // Format the requirements sheet
      const headerRange = wsReq.getRange("A1:G1"); // Extended to G1
      headerRange.setFontWeight("bold");
      headerRange.setBackground("#4285f4");
      headerRange.setFontColor("white");
      
      // Auto-resize columns
      wsReq.autoResizeColumns(1, 7); // Now 7 columns
      
      // Format number columns (Total Required, Current Inventory, Difference are now in columns 4, 5, 6)
      wsReq.getRange(2, 4, results.length, 3).setNumberFormat("#,##0");
      wsReq.getRange(2, 7, results.length, 1).setHorizontalAlignment("center"); // Cases Needed column
      
      // Center align Location Id column
      wsReq.getRange(2, 3, results.length, 1).setHorizontalAlignment("center");
      
      // Add conditional formatting for negative differences (shortages) - now column F
      const diffRange = wsReq.getRange(2, 6, results.length, 1);
      const rule = SpreadsheetApp.newConditionalFormatRule()
        .whenNumberLessThan(0)
        .setBackground("#ff9999")
        .setRanges([diffRange])
        .build();
      const rules = wsReq.getConditionalFormatRules();
      rules.push(rule);
      wsReq.setConditionalFormatRules(rules);
      
      // Add conditional formatting for cases needed > 0 - now column G
      const casesRange = wsReq.getRange(2, 7, results.length, 1);
      const casesRule = SpreadsheetApp.newConditionalFormatRule()
        .whenNumberGreaterThan(0)
        .setBackground("#c9daf8")
        .setRanges([casesRange])
        .build();
      const allRules = wsReq.getConditionalFormatRules();
      allRules.push(casesRule);
      wsReq.setConditionalFormatRules(allRules);
      
      // Add conditional formatting to highlight items without location IDs
      const locationRange = wsReq.getRange(2, 3, results.length, 1);
      const noLocationRule = SpreadsheetApp.newConditionalFormatRule()
        .whenTextEqualTo("Not Found")
        .setBackground("#ffe6cc")
        .setFontColor("#cc6600")
        .setRanges([locationRange])
        .build();
      const finalRules = wsReq.getConditionalFormatRules();
      finalRules.push(noLocationRule);
      wsReq.setConditionalFormatRules(finalRules);
    }
    
    // Count items with and without locations for the summary
    const itemsWithLocation = results.filter(row => row[2] !== "Not Found").length;
    const itemsWithoutLocation = results.filter(row => row[2] === "Not Found").length;
    
    SpreadsheetApp.getUi().alert(`Inventory requirements calculation complete! 
    
Processed ${results.length} unique SKUs across ${recipesData.length - 1} recipe entries.
${itemsWithLocation} items have location assignments.
${itemsWithoutLocation} items need location assignments.
    
Results are sorted by Location ID, then by Item Number.`);
    
  } catch (error) {
    SpreadsheetApp.getUi().alert("Error: " + error.toString());
    console.error("Error in calculateInventoryRequirements:", error);
  }
}

// Updated helper function to debug specific SKU calculations (now includes location info)
function debugSpecificSKU(targetSKU) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const wsRecipes = ss.getSheetByName("Recipes");
  const wsPlan = ss.getSheetByName("Kitting_Plan");
  const wsSlotting = ss.getSheetByName("Slotting File");
  
  const recipesData = wsRecipes.getDataRange().getValues();
  const planData = wsPlan.getDataRange().getValues();
  
  console.log(`\n=== DEBUG FOR SKU: ${targetSKU} ===`);
  
  // Check location first
  if (wsSlotting) {
    const slottingData = wsSlotting.getDataRange().getValues();
    const locationRow = slottingData.find(row => row[2] === targetSKU);
    if (locationRow) {
      console.log(`Location: ${locationRow[0]} (${locationRow[1]})`);
    } else {
      console.log(`Location: Not Found`);
    }
  }
  
  let totalForSKU = 0;
  
  for (let i = 1; i < recipesData.length; i++) {
    const recipeNum = recipesData[i][1];
    const itemDesc = recipesData[i][3];
    const qty2p = parseFloat(recipesData[i][4]) || 0;
    const qty4p = parseFloat(recipesData[i][5]) || 0;
    const itemNum = recipesData[i][6];
    
    if (itemNum == targetSKU) {
      // Find plan for this recipe
      let plan2p = 0;
      let plan4p = 0;
      
      for (let k = 1; k < planData.length; k++) {
        // Compare as strings to handle both numbers and letters
        if (String(planData[k][0]) === String(recipeNum)) {
          plan2p = parseFloat(planData[k][1]) || 0;
          plan4p = parseFloat(planData[k][2]) || 0;
          break;
        }
      }
      
      const req2p = qty2p * plan2p;
      const req4p = qty4p * plan4p;
      const recipeTotal = req2p + req4p;
      totalForSKU += recipeTotal;
      
      console.log(`Recipe ${recipeNum} (${itemDesc}): 2p=${qty2p}*${plan2p}=${req2p}, 4p=${qty4p}*${plan4p}=${req4p}, Total=${recipeTotal}`);
    }
  }
  
  console.log(`TOTAL FOR SKU ${targetSKU}: ${totalForSKU}`);
}

// Updated helper function to debug data structure (now includes slotting sheet)
function debugDataStructure() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const wsInv = ss.getSheetByName("Inventory");
  const wsRecipes = ss.getSheetByName("Recipes");
  const wsPlan = ss.getSheetByName("Kitting_Plan");
  const wsSlotting = ss.getSheetByName("Slotting File");
  
  console.log("=== INVENTORY SHEET STRUCTURE ===");
  const invData = wsInv.getDataRange().getValues();
  console.log("Headers:", invData[0]);
  if (invData.length > 1) console.log("Sample row:", invData[1]);
  
  console.log("\n=== RECIPES SHEET STRUCTURE ===");
  const recData = wsRecipes.getDataRange().getValues();
  console.log("Headers:", recData[0]);
  if (recData.length > 1) console.log("Sample row:", recData[1]);
  
  console.log("\n=== KITTING PLAN SHEET STRUCTURE ===");
  const planData = wsPlan.getDataRange().getValues();
  console.log("Headers:", planData[0]);
  if (planData.length > 1) console.log("Sample row:", planData[1]);
  
  if (wsSlotting) {
    console.log("\n=== SLOTTING FILE SHEET STRUCTURE ===");
    const slottingData = wsSlotting.getDataRange().getValues();
    console.log("Headers:", slottingData[0]);
    if (slottingData.length > 1) console.log("Sample row:", slottingData[1]);
    console.log(`Total slotting entries: ${slottingData.length - 1}`);
  } else {
    console.log("\n❌ SLOTTING FILE SHEET NOT FOUND");
  }
  
  // Count unique recipes and SKUs
  const uniqueRecipes = new Set();
  const uniqueSKUs = new Set();
  
  for (let i = 1; i < recData.length; i++) {
    if (recData[i][1]) uniqueRecipes.add(String(recData[i][1])); // Convert to string
    if (recData[i][6]) uniqueSKUs.add(recData[i][6]);
  }
  
  console.log(`\nFound ${uniqueRecipes.size} unique recipes and ${uniqueSKUs.size} unique SKUs`);
  
  // Show sample of recipe types found
  const sampleRecipes = Array.from(uniqueRecipes).slice(0, 10);
  console.log("Sample recipe codes found:", sampleRecipes);
}

// Helper function to check location coverage
function debugLocationCoverage() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const wsRecipes = ss.getSheetByName("Recipes");
  const wsSlotting = ss.getSheetByName("Slotting File");
  
  if (!wsSlotting) {
    console.log("❌ Slotting File sheet not found!");
    return;
  }
  
  const recipesData = wsRecipes.getDataRange().getValues();
  const slottingData = wsSlotting.getDataRange().getValues();
  
  console.log("=== LOCATION COVERAGE ANALYSIS ===");
  
  // Get all unique SKUs from recipes
  const requiredSKUs = new Set();
  for (let i = 1; i < recipesData.length; i++) {
    if (recipesData[i][6]) { // Column G - Item Number
      requiredSKUs.add(recipesData[i][6]);
    }
  }
  
  // Get all SKUs that have locations
  const skusWithLocations = new Set();
  for (let i = 1; i < slottingData.length; i++) {
    if (slottingData[i][2]) { // Column C - Item Number in slotting file
      skusWithLocations.add(slottingData[i][2]);
    }
  }
  
  const totalRequired = requiredSKUs.size;
  const totalWithLocations = Array.from(requiredSKUs).filter(sku => skusWithLocations.has(sku)).length;
  const missingLocations = Array.from(requiredSKUs).filter(sku => !skusWithLocations.has(sku));
  
  console.log(`Total unique SKUs needed: ${totalRequired}`);
  console.log(`SKUs with locations: ${totalWithLocations}`);
  console.log(`SKUs missing locations: ${totalRequired - totalWithLocations}`);
  console.log(`Coverage: ${((totalWithLocations / totalRequired) * 100).toFixed(1)}%`);
  
  if (missingLocations.length > 0) {
    console.log("\nSKUs missing locations (first 10):", missingLocations.slice(0, 10));
  }
}

// Updated custom menu
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('Inventory Tools')
    .addItem('Calculate Requirements', 'calculateInventoryRequirements')
    .addSeparator()
    .addItem('Debug Data Structure', 'debugDataStructure')
    .addItem('Debug Recipe Matching', 'debugRecipeMatching')
    .addItem('Debug Location Coverage', 'debugLocationCoverage')
    .addSeparator()
    .addItem('Debug Specific SKU', 'debugSpecificSKUPrompt')
    .addToUi();
}

function debugSpecificSKUPrompt() {
  const ui = SpreadsheetApp.getUi();
  const result = ui.prompt('Debug SKU', 'Enter the SKU to debug:', ui.ButtonSet.OK_CANCEL);
  
  if (result.getSelectedButton() == ui.Button.OK) {
    const sku = result.getResponseText();
    debugSpecificSKU(sku);
    ui.alert('Check the console (Extensions → Apps Script → View → Logs) for debug information');
  }
}
